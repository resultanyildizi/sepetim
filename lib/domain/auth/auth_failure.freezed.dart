// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

  _CancelledByUser cancelledByUser() {
    return const _CancelledByUser();
  }

  _ServerError serverError() {
    return const _ServerError();
  }

  _EmailAlreadyInUse emailAlreadyInUse() {
    return const _EmailAlreadyInUse();
  }

  _NetworkException networkException() {
    return const _NetworkException();
  }

  _WrongPassword wrongPassword() {
    return const _WrongPassword();
  }

  _TooManyRequests tooManyRequests() {
    return const _TooManyRequests();
  }

  _UserNotFound userNotFound() {
    return const _UserNotFound();
  }

  _AccountAlreadyExists accountAlreadyExists() {
    return const _AccountAlreadyExists();
  }

  _AccountAlreadyLinked accountAlreadyLinked() {
    return const _AccountAlreadyLinked();
  }

  _InvalidCredential invalidCredential() {
    return const _InvalidCredential();
  }

  _UserNotUsingEmailProvider userNotUsingEmailProvider() {
    return const _UserNotUsingEmailProvider();
  }

  _InvalidEmailAndPasswordCombination invalidEmailAndPasswordCombination() {
    return const _InvalidEmailAndPasswordCombination();
  }
}

// ignore: unused_element
const $AuthFailure = _$AuthFailureTearOff();

mixin _$AuthFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  });
}

abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
}

class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;
}

abstract class _$CancelledByUserCopyWith<$Res> {
  factory _$CancelledByUserCopyWith(
          _CancelledByUser value, $Res Function(_CancelledByUser) then) =
      __$CancelledByUserCopyWithImpl<$Res>;
}

class __$CancelledByUserCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$CancelledByUserCopyWith<$Res> {
  __$CancelledByUserCopyWithImpl(
      _CancelledByUser _value, $Res Function(_CancelledByUser) _then)
      : super(_value, (v) => _then(v as _CancelledByUser));

  @override
  _CancelledByUser get _value => super._value as _CancelledByUser;
}

class _$_CancelledByUser implements _CancelledByUser {
  const _$_CancelledByUser();

  @override
  String toString() {
    return 'AuthFailure.cancelledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CancelledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return cancelledByUser();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class _CancelledByUser implements AuthFailure {
  const factory _CancelledByUser() = _$_CancelledByUser;
}

abstract class _$ServerErrorCopyWith<$Res> {
  factory _$ServerErrorCopyWith(
          _ServerError value, $Res Function(_ServerError) then) =
      __$ServerErrorCopyWithImpl<$Res>;
}

class __$ServerErrorCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$ServerErrorCopyWith<$Res> {
  __$ServerErrorCopyWithImpl(
      _ServerError _value, $Res Function(_ServerError) _then)
      : super(_value, (v) => _then(v as _ServerError));

  @override
  _ServerError get _value => super._value as _ServerError;
}

class _$_ServerError implements _ServerError {
  const _$_ServerError();

  @override
  String toString() {
    return 'AuthFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _ServerError implements AuthFailure {
  const factory _ServerError() = _$_ServerError;
}

abstract class _$EmailAlreadyInUseCopyWith<$Res> {
  factory _$EmailAlreadyInUseCopyWith(
          _EmailAlreadyInUse value, $Res Function(_EmailAlreadyInUse) then) =
      __$EmailAlreadyInUseCopyWithImpl<$Res>;
}

class __$EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmailAlreadyInUseCopyWith<$Res> {
  __$EmailAlreadyInUseCopyWithImpl(
      _EmailAlreadyInUse _value, $Res Function(_EmailAlreadyInUse) _then)
      : super(_value, (v) => _then(v as _EmailAlreadyInUse));

  @override
  _EmailAlreadyInUse get _value => super._value as _EmailAlreadyInUse;
}

class _$_EmailAlreadyInUse implements _EmailAlreadyInUse {
  const _$_EmailAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyInUse implements AuthFailure {
  const factory _EmailAlreadyInUse() = _$_EmailAlreadyInUse;
}

abstract class _$NetworkExceptionCopyWith<$Res> {
  factory _$NetworkExceptionCopyWith(
          _NetworkException value, $Res Function(_NetworkException) then) =
      __$NetworkExceptionCopyWithImpl<$Res>;
}

class __$NetworkExceptionCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$NetworkExceptionCopyWith<$Res> {
  __$NetworkExceptionCopyWithImpl(
      _NetworkException _value, $Res Function(_NetworkException) _then)
      : super(_value, (v) => _then(v as _NetworkException));

  @override
  _NetworkException get _value => super._value as _NetworkException;
}

class _$_NetworkException implements _NetworkException {
  const _$_NetworkException();

  @override
  String toString() {
    return 'AuthFailure.networkException()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NetworkException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return networkException();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (networkException != null) {
      return networkException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return networkException(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (networkException != null) {
      return networkException(this);
    }
    return orElse();
  }
}

abstract class _NetworkException implements AuthFailure {
  const factory _NetworkException() = _$_NetworkException;
}

abstract class _$WrongPasswordCopyWith<$Res> {
  factory _$WrongPasswordCopyWith(
          _WrongPassword value, $Res Function(_WrongPassword) then) =
      __$WrongPasswordCopyWithImpl<$Res>;
}

class __$WrongPasswordCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$WrongPasswordCopyWith<$Res> {
  __$WrongPasswordCopyWithImpl(
      _WrongPassword _value, $Res Function(_WrongPassword) _then)
      : super(_value, (v) => _then(v as _WrongPassword));

  @override
  _WrongPassword get _value => super._value as _WrongPassword;
}

class _$_WrongPassword implements _WrongPassword {
  const _$_WrongPassword();

  @override
  String toString() {
    return 'AuthFailure.wrongPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _WrongPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return wrongPassword();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongPassword != null) {
      return wrongPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return wrongPassword(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (wrongPassword != null) {
      return wrongPassword(this);
    }
    return orElse();
  }
}

abstract class _WrongPassword implements AuthFailure {
  const factory _WrongPassword() = _$_WrongPassword;
}

abstract class _$TooManyRequestsCopyWith<$Res> {
  factory _$TooManyRequestsCopyWith(
          _TooManyRequests value, $Res Function(_TooManyRequests) then) =
      __$TooManyRequestsCopyWithImpl<$Res>;
}

class __$TooManyRequestsCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$TooManyRequestsCopyWith<$Res> {
  __$TooManyRequestsCopyWithImpl(
      _TooManyRequests _value, $Res Function(_TooManyRequests) _then)
      : super(_value, (v) => _then(v as _TooManyRequests));

  @override
  _TooManyRequests get _value => super._value as _TooManyRequests;
}

class _$_TooManyRequests implements _TooManyRequests {
  const _$_TooManyRequests();

  @override
  String toString() {
    return 'AuthFailure.tooManyRequests()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _TooManyRequests);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return tooManyRequests();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooManyRequests != null) {
      return tooManyRequests();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return tooManyRequests(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooManyRequests != null) {
      return tooManyRequests(this);
    }
    return orElse();
  }
}

abstract class _TooManyRequests implements AuthFailure {
  const factory _TooManyRequests() = _$_TooManyRequests;
}

abstract class _$UserNotFoundCopyWith<$Res> {
  factory _$UserNotFoundCopyWith(
          _UserNotFound value, $Res Function(_UserNotFound) then) =
      __$UserNotFoundCopyWithImpl<$Res>;
}

class __$UserNotFoundCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$UserNotFoundCopyWith<$Res> {
  __$UserNotFoundCopyWithImpl(
      _UserNotFound _value, $Res Function(_UserNotFound) _then)
      : super(_value, (v) => _then(v as _UserNotFound));

  @override
  _UserNotFound get _value => super._value as _UserNotFound;
}

class _$_UserNotFound implements _UserNotFound {
  const _$_UserNotFound();

  @override
  String toString() {
    return 'AuthFailure.userNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UserNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return userNotFound();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userNotFound != null) {
      return userNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return userNotFound(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userNotFound != null) {
      return userNotFound(this);
    }
    return orElse();
  }
}

abstract class _UserNotFound implements AuthFailure {
  const factory _UserNotFound() = _$_UserNotFound;
}

abstract class _$AccountAlreadyExistsCopyWith<$Res> {
  factory _$AccountAlreadyExistsCopyWith(_AccountAlreadyExists value,
          $Res Function(_AccountAlreadyExists) then) =
      __$AccountAlreadyExistsCopyWithImpl<$Res>;
}

class __$AccountAlreadyExistsCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$AccountAlreadyExistsCopyWith<$Res> {
  __$AccountAlreadyExistsCopyWithImpl(
      _AccountAlreadyExists _value, $Res Function(_AccountAlreadyExists) _then)
      : super(_value, (v) => _then(v as _AccountAlreadyExists));

  @override
  _AccountAlreadyExists get _value => super._value as _AccountAlreadyExists;
}

class _$_AccountAlreadyExists implements _AccountAlreadyExists {
  const _$_AccountAlreadyExists();

  @override
  String toString() {
    return 'AuthFailure.accountAlreadyExists()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _AccountAlreadyExists);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return accountAlreadyExists();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accountAlreadyExists != null) {
      return accountAlreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return accountAlreadyExists(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accountAlreadyExists != null) {
      return accountAlreadyExists(this);
    }
    return orElse();
  }
}

abstract class _AccountAlreadyExists implements AuthFailure {
  const factory _AccountAlreadyExists() = _$_AccountAlreadyExists;
}

abstract class _$AccountAlreadyLinkedCopyWith<$Res> {
  factory _$AccountAlreadyLinkedCopyWith(_AccountAlreadyLinked value,
          $Res Function(_AccountAlreadyLinked) then) =
      __$AccountAlreadyLinkedCopyWithImpl<$Res>;
}

class __$AccountAlreadyLinkedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$AccountAlreadyLinkedCopyWith<$Res> {
  __$AccountAlreadyLinkedCopyWithImpl(
      _AccountAlreadyLinked _value, $Res Function(_AccountAlreadyLinked) _then)
      : super(_value, (v) => _then(v as _AccountAlreadyLinked));

  @override
  _AccountAlreadyLinked get _value => super._value as _AccountAlreadyLinked;
}

class _$_AccountAlreadyLinked implements _AccountAlreadyLinked {
  const _$_AccountAlreadyLinked();

  @override
  String toString() {
    return 'AuthFailure.accountAlreadyLinked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _AccountAlreadyLinked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return accountAlreadyLinked();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accountAlreadyLinked != null) {
      return accountAlreadyLinked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return accountAlreadyLinked(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (accountAlreadyLinked != null) {
      return accountAlreadyLinked(this);
    }
    return orElse();
  }
}

abstract class _AccountAlreadyLinked implements AuthFailure {
  const factory _AccountAlreadyLinked() = _$_AccountAlreadyLinked;
}

abstract class _$InvalidCredentialCopyWith<$Res> {
  factory _$InvalidCredentialCopyWith(
          _InvalidCredential value, $Res Function(_InvalidCredential) then) =
      __$InvalidCredentialCopyWithImpl<$Res>;
}

class __$InvalidCredentialCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidCredentialCopyWith<$Res> {
  __$InvalidCredentialCopyWithImpl(
      _InvalidCredential _value, $Res Function(_InvalidCredential) _then)
      : super(_value, (v) => _then(v as _InvalidCredential));

  @override
  _InvalidCredential get _value => super._value as _InvalidCredential;
}

class _$_InvalidCredential implements _InvalidCredential {
  const _$_InvalidCredential();

  @override
  String toString() {
    return 'AuthFailure.invalidCredential()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InvalidCredential);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return invalidCredential();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCredential != null) {
      return invalidCredential();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return invalidCredential(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCredential != null) {
      return invalidCredential(this);
    }
    return orElse();
  }
}

abstract class _InvalidCredential implements AuthFailure {
  const factory _InvalidCredential() = _$_InvalidCredential;
}

abstract class _$UserNotUsingEmailProviderCopyWith<$Res> {
  factory _$UserNotUsingEmailProviderCopyWith(_UserNotUsingEmailProvider value,
          $Res Function(_UserNotUsingEmailProvider) then) =
      __$UserNotUsingEmailProviderCopyWithImpl<$Res>;
}

class __$UserNotUsingEmailProviderCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$UserNotUsingEmailProviderCopyWith<$Res> {
  __$UserNotUsingEmailProviderCopyWithImpl(_UserNotUsingEmailProvider _value,
      $Res Function(_UserNotUsingEmailProvider) _then)
      : super(_value, (v) => _then(v as _UserNotUsingEmailProvider));

  @override
  _UserNotUsingEmailProvider get _value =>
      super._value as _UserNotUsingEmailProvider;
}

class _$_UserNotUsingEmailProvider implements _UserNotUsingEmailProvider {
  const _$_UserNotUsingEmailProvider();

  @override
  String toString() {
    return 'AuthFailure.userNotUsingEmailProvider()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UserNotUsingEmailProvider);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return userNotUsingEmailProvider();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userNotUsingEmailProvider != null) {
      return userNotUsingEmailProvider();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return userNotUsingEmailProvider(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userNotUsingEmailProvider != null) {
      return userNotUsingEmailProvider(this);
    }
    return orElse();
  }
}

abstract class _UserNotUsingEmailProvider implements AuthFailure {
  const factory _UserNotUsingEmailProvider() = _$_UserNotUsingEmailProvider;
}

abstract class _$InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  factory _$InvalidEmailAndPasswordCombinationCopyWith(
          _InvalidEmailAndPasswordCombination value,
          $Res Function(_InvalidEmailAndPasswordCombination) then) =
      __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>;
}

class __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  __$InvalidEmailAndPasswordCombinationCopyWithImpl(
      _InvalidEmailAndPasswordCombination _value,
      $Res Function(_InvalidEmailAndPasswordCombination) _then)
      : super(_value, (v) => _then(v as _InvalidEmailAndPasswordCombination));

  @override
  _InvalidEmailAndPasswordCombination get _value =>
      super._value as _InvalidEmailAndPasswordCombination;
}

class _$_InvalidEmailAndPasswordCombination
    implements _InvalidEmailAndPasswordCombination {
  const _$_InvalidEmailAndPasswordCombination();

  @override
  String toString() {
    return 'AuthFailure.invalidEmailAndPasswordCombination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvalidEmailAndPasswordCombination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result cancelledByUser(),
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
    @required Result networkException(),
    @required Result wrongPassword(),
    @required Result tooManyRequests(),
    @required Result userNotFound(),
    @required Result accountAlreadyExists(),
    @required Result accountAlreadyLinked(),
    @required Result invalidCredential(),
    @required Result userNotUsingEmailProvider(),
    @required Result invalidEmailAndPasswordCombination(),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return invalidEmailAndPasswordCombination();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result cancelledByUser(),
    Result serverError(),
    Result emailAlreadyInUse(),
    Result networkException(),
    Result wrongPassword(),
    Result tooManyRequests(),
    Result userNotFound(),
    Result accountAlreadyExists(),
    Result accountAlreadyLinked(),
    Result invalidCredential(),
    Result userNotUsingEmailProvider(),
    Result invalidEmailAndPasswordCombination(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result cancelledByUser(_CancelledByUser value),
    @required Result serverError(_ServerError value),
    @required Result emailAlreadyInUse(_EmailAlreadyInUse value),
    @required Result networkException(_NetworkException value),
    @required Result wrongPassword(_WrongPassword value),
    @required Result tooManyRequests(_TooManyRequests value),
    @required Result userNotFound(_UserNotFound value),
    @required Result accountAlreadyExists(_AccountAlreadyExists value),
    @required Result accountAlreadyLinked(_AccountAlreadyLinked value),
    @required Result invalidCredential(_InvalidCredential value),
    @required
        Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    @required
        Result invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
  }) {
    assert(cancelledByUser != null);
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    assert(networkException != null);
    assert(wrongPassword != null);
    assert(tooManyRequests != null);
    assert(userNotFound != null);
    assert(accountAlreadyExists != null);
    assert(accountAlreadyLinked != null);
    assert(invalidCredential != null);
    assert(userNotUsingEmailProvider != null);
    assert(invalidEmailAndPasswordCombination != null);
    return invalidEmailAndPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result cancelledByUser(_CancelledByUser value),
    Result serverError(_ServerError value),
    Result emailAlreadyInUse(_EmailAlreadyInUse value),
    Result networkException(_NetworkException value),
    Result wrongPassword(_WrongPassword value),
    Result tooManyRequests(_TooManyRequests value),
    Result userNotFound(_UserNotFound value),
    Result accountAlreadyExists(_AccountAlreadyExists value),
    Result accountAlreadyLinked(_AccountAlreadyLinked value),
    Result invalidCredential(_InvalidCredential value),
    Result userNotUsingEmailProvider(_UserNotUsingEmailProvider value),
    Result invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAndPasswordCombination implements AuthFailure {
  const factory _InvalidEmailAndPasswordCombination() =
      _$_InvalidEmailAndPasswordCombination;
}
